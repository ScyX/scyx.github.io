<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一文理解ThreadLocal]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%B8%80%E6%96%87%E7%90%86%E8%A7%A3ThreadLocal%2F</url>
    <content type="text"><![CDATA[概述到底什么是ThreadLocal？ 我们先来看看JDK里是怎么说的(JDK1.8)。1234567891011121314151617181920This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized * copy of the variable. &#123;@code ThreadLocal&#125; instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). * * &lt;p&gt;For example, the class below generates unique identifiers local to each * thread. * A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125; * and remains unchanged on subsequent calls. &lt;/pre&gt; * &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local * variable as long as the thread is alive and the &#123;@code ThreadLocal&#125; * instance is accessible; after a thread goes away, all of its copies of * thread-local instances are subject to garbage collection (unless other * references to these copies exist). 谷歌翻译一下 该类提供线程局部变量。 这些变量不同于它们的正常对应物是每个访问一个（通过它或方法）的线程都有自己独立初始化的变量副本。 实例通常是希望将状态与线程相关联的类中的私有静态字段（例如，用户ID或事务ID）。 每个线程都拥有对其本地线程副本的隐式引用只要线程处于活动状态，就可以变量实例可访问; 一个线程消失后，它的所有副本程局部实例受垃圾回收（除非其他存在对这些副本的引用）。 那么到底什么意思呢？ThreadLocal提供了线程的局部变量，每个线程访问到的ThreadLocal并且往其中set()的变量是属于当前线程的，其他线程访问不到，实现了线程的数据隔离。 内部实现想要深入了解ThreadLocal，还是先看一下代码吧。123456789101112//JDK1.8中ThreadLocal的 set源码public void set(T value) &#123; //得到当前线程对象 Thread t = Thread.currentThread(); //获取当前线程对象的ThreadLocalMap ThreadLocalMap map = getMap(t); //如果map存在，则t作为key，要存的对象作为value，存到map中 if (map != null) map.set(this, value); else createMap(t, value); &#125; 看了这段代码 又有了疑问，什么是ThreadLocalMap？点进去看看1234567891011121314151617181920static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; &#125; 原来ThreadLocalMap是ThreadLocal的一个内部类，数据是用Entry存储的。看看getMap方法123456ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; 什么是threadLocals？ threadLocals在Thread类中为线程维护的一个threadlocalMap ThreadLocal.ThreadLocalMap threadLocals = null; 这就清楚多了，从上面来看，一个Thread维护一个ThreadLocalMap，ThreadLocalMap的set方法的key是ThreadLocal本身，value是要存储的对象。再来看看get方法，有了以上的基础，那么看get方法我相信已经没有难度了1234567891011121314public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; // 还是根据当前线程对象从ThreadLocalMap的内部类Entry中取值 总结 一个Thread维护一个ThreadLocalMap set方法是通过ThreadLocalMap的内部类Entry来存储 ThreadLocalMap的set方法的key是ThreadLocal本身，value是要存储的对象 ThreadLocal是通过ThreadLocalMap来存储值，本身并不存储值，只是作为一个key 综上所述，ThreadLocal才能实现线程间的数据隔离]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引原理]]></title>
    <url>%2F2019%2F05%2F02%2FMySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[索引目的索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？ 索引原理除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。 索引的数据结构前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。 详解b+树如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。 b+树查找过程如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。 b+树性质 通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。 建索引的几大原则 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 本文转载自：《美团技术团队：MySQL索引原理及慢查询优化》]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.18腾讯暑期实习招聘提前批一面(挂)]]></title>
    <url>%2F2019%2F04%2F16%2F2019-3-18%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[3.18晚上9点 人生第一次面试 岗位：后台开发 我是做Java，但是估计面试官不是做Java的所以一点Java的东西也没问 了解redis高可用吗 异步队列怎么做的? redis和数据库的关系,是先写redis还是数据库 redis崩溃了如何减轻数据库的压力 用过什么redis命令 操作系统相关 select epoll 进程线程区别 进程通信方式 操作系统有哪些锁 TCP三次握手 粘包问题 如何访问到链表的中间节点暂时记得的只有这么多了 关于操作系统和场景题答的不好给自己敲了警钟，知道自己还差的远。在学习的时候一定要结合自己的思考，往深处挖，不能只是停留在表面，要理解原理。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java排序算法之插入排序]]></title>
    <url>%2F2019%2F04%2F16%2FJava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[什么是插入排序插入排序的基本思想就是把一个数插入到已经有序的数列中，形式就像平时打牌一样，要把一张牌插到已经有的牌中。这里只是要把牌看成数组。初始时要把数组的第一个元素看成有序列表，从第二个数开始，依次将当前数插入到前面的有序列表中。12345678910111213141516public static void main(String[] args)&#123; int[] arr=&#123;5,4,3,2,1&#125;; for(int i=1;i&lt;arr.length;i++)&#123; //第一次把第一个元素也就是数组的0位置上的数看成有序，所以从1位置也就是数组的第二个数开始 int temp=arr[i]; //当前数 int left=i-1; //把当前数的前面的所有数都看成有序列表 while(left&gt;=0&amp;&amp;temp&lt;arr[left])&#123; //依次和前面的数比较，如果当前数比前面的数小 就把前面的数后移一位，继续向前比，直到不比前面的数小为止 arr[left+1]=arr[left]; left--; &#125; arr[left+1]=temp; //把当前数插入，因为之前的元素都向后移了，总会有一个空的位置，这个位置就是这个数应该插入在有序列表中的位置 &#125; for(int a:arr)&#123; System.out.println(a);//由于此处采用的是从小到大排，所以结果应该为1,2,3,4,5 &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中接口和抽象类的区别]]></title>
    <url>%2F2019%2F04%2F15%2FJava%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。“抽象方法”,属于一种不完整的方法，只含有一个声明，没有方法主体也就是没有{}，抽象类不能被实例化（也就是不能用抽象类new）。 接口接口是一系列方法的声明，是一些方法特征的集合，接口里面只有方法的声明而没有方法的实现，也就是没有方法主体，没有{}，里面的方法都是由public abstract修饰的。 区别 抽象类可以有具体的方法实现，而接口是完全抽象的，不能有方法实现。 子类使用extends继承抽象类，如果子类不是抽象类的话，要实现抽象类的全部抽象方法。子类使用implements实现接口，并且要实现接口声明的全部方法。 修饰符：抽象类可以用public protected和default这些修饰符，接口方法默认修饰符是public，不可以用其他修饰符。 抽象类可以有main方法也可以运行，接口不能有main，也不能运行。 抽象方法可以继承一个类和实现多个接口，接口只可以继承一个或多个其它接口。 抽象类比接口速度要快，因为接口需要时间去寻找在类中实现的方法。 往抽象类中添加新的方法可以直接提供实现，所以可以不用改变继承抽象类的子类，而向接口添加新的方法，必须改变接口的实现类。 抽象类可以有构造方法，只是不能创建抽象类的实例化对象，接口没有构造方法，不能被实例化。 什么时候使用抽象类？什么时候使用接口？ 如果拥有一些方法并且想让它们中的一些有默认实现，用抽象类。 由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。这时候可以使用接口解决问题。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
