<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[final关键字]]></title>
    <url>%2F2019%2F05%2F22%2Ffinal%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[final是Java中的关键字，可以修饰变量，方法，类 final 这个关键字的含义是这是无法改变的或者终态的；一旦引用使用final修饰，那么这个引用就不能再改变，否则，编译器将会报编译错误。 修饰变量1public static final int TOKEN_EXPIRE = 3600*24 * 2; 这是我在代码中定义过的一个final变量，用final修饰以后，该值不可变，再次对TOKEN_EXPIRE赋值就会报错。如果修饰引用类型，那么该引用不可变，但是引用的对象是可以被改变的 修饰类String类是一个被final修饰的类，那么被final修饰的类，不可被继承，如果一个类不希望被继承，可以用final修饰，被final修饰的类中的所有方法都被final修饰，也就是不可被重写 这就是String类不可变的原因。 修饰方法final关键字修饰方法说明该方法不可被子类重写 修饰形参该形参在方法中不可被改变 好处 final关键字提高了性能。JVM和Java应用都会缓存final变量。 final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。 使用final关键字，JVM会对方法、变量及类进行优化。 ##注意按照Java代码惯例，final变量就是常量，而且通常常量名要大写final关键字不同于finally关键字，后者用于异常处理。final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。final关键字即使在定义的时候未被赋值，但是在每个构造器中一定要赋值，如果没有赋值，系统也不会为它赋值，该变量定义出来毫无意义。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网刷题记录2019.5.9]]></title>
    <url>%2F2019%2F05%2F09%2F%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%952019-5-9%2F</url>
    <content type="text"><![CDATA[一个以”.java”为后缀的源文件只能有一个与文件名相同的public类，可以包含其他类 下面有关java实例变量,局部变量,类变量和final变量的说法，错误的是？正确答案: B 你的答案: A (错误)A.实例变量指的是类中定义的变量，即成员变量，如果没有初始化，会有默认值。B.局部变量指的是在方法中定义的变量，如果没有初始化，会有默认值C.类变量指的是用static修饰的属性D.final变量指的是用final 修饰的变量 答案为B 局部变量如何被用到必须赋初值 如果一个接口Cup有个方法use()，有个类SmallCup实现接口Cup，则在类SmallCup中正确的是？正确答案: C 你的答案: D (错误)A.void use() { …}B.protected void use() { …}C.public void use() { …}D.以上语句都可以用在类SmallCup中 既然是实现接口，就要实现接口的所以方法，相当于重写方法，方法的重写需要满足：两同两小一大（方法名、参数列表相同；返回类型，抛出异常&lt;=重写前；访问权限&gt;=重写前； 下面哪个不属于HttpServletResponse接口完成的功能？正确答案: C 你的答案: A (错误)A.设置HTTP头标B.设置cookieC.读取路径信息D.输出返回数据答案：CA：设置HTTP头标response.setHeader(“Refresh”,”3”); //三秒刷新页面一次B：设置cookieCookie c1 = new Cookie(“username”,”only”);response.addCookie(c1);C（错误）：读取路径信息,request读取路径信息从request获取各种路径总结request.getRealPath(“url”); // 虚拟目录映射为实际目录request.getRealPath(“./“); // 网页所在的目录request.getRealPath(“../“); // 网页所在目录的上一层目录request.getContextPath(); // 应用的web目录的名称D：输出返回数据HttpServleteResponse.getOutputStream().write();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot自动配置原理]]></title>
    <url>%2F2019%2F05%2F05%2FSpringboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @AliasFor( annotation = EnableAutoConfiguration.class ) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor( annotation = EnableAutoConfiguration.class ) String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackages" ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackageClasses" ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125; 总结SpringBoot启动的时候，不论调用什么方法，都会构造一个SpringApplication的实例，然后调用这个实例的run方法，这样就表示启动SpringBoot。在run方法调用之前，也就是构造SpringApplication的时候会进行初始化的工作，初始化的时候会做以下几件事： 把参数sources设置到SpringApplication属性中，这个sources可以是任何类型的参数。本文的例子中这个sources就是MyApplication的class对象判断是否是web程序，并设置到webEnvironment这个boolean属性中找出所有的初始化器，默认有5个，设置到initializers属性中找出所有的应用程序监听器，默认有9个，设置到listeners属性中找出运行的主类(main class) SpringApplication构造完成之后调用run方法，启动SpringApplication，run方法执行的时候会做以下几件事： 构造一个StopWatch，观察SpringApplication的执行找出所有的SpringApplicationRunListener并封装到SpringApplicationRunListeners中，用于监听run方法的执行。监听的过程中会封装成事件并广播出去让初始化过程中产生的应用程序监听器进行监听构造Spring容器(ApplicationContext)，并返回3.1 创建Spring容器的判断是否是web环境，是的话构造AnnotationConfigEmbeddedWebApplicationContext，否则构造AnnotationConfigApplicationContext3.2 初始化过程中产生的初始化器在这个时候开始工作3.3 Spring容器的刷新(完成bean的解析、各种processor接口的执行、条件注解的解析等等)从Spring容器中找出ApplicationRunner和CommandLineRunner接口的实现类并排序后依次执行 作者：丶Format链接：https://www.jianshu.com/p/d51e1896a5f7来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>-Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文理解ThreadLocal]]></title>
    <url>%2F2019%2F05%2F03%2F%E4%B8%80%E6%96%87%E7%90%86%E8%A7%A3ThreadLocal%2F</url>
    <content type="text"><![CDATA[概述到底什么是ThreadLocal？ 我们先来看看JDK里是怎么说的(JDK1.8)。1234567891011121314151617181920This class provides thread-local variables. These variables differ from * their normal counterparts in that each thread that accesses one (via its * &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized * copy of the variable. &#123;@code ThreadLocal&#125; instances are typically private * static fields in classes that wish to associate state with a thread (e.g., * a user ID or Transaction ID). * * &lt;p&gt;For example, the class below generates unique identifiers local to each * thread. * A thread&apos;s id is assigned the first time it invokes &#123;@code ThreadId.get()&#125; * and remains unchanged on subsequent calls. &lt;/pre&gt; * &lt;p&gt;Each thread holds an implicit reference to its copy of a thread-local * variable as long as the thread is alive and the &#123;@code ThreadLocal&#125; * instance is accessible; after a thread goes away, all of its copies of * thread-local instances are subject to garbage collection (unless other * references to these copies exist). 谷歌翻译一下 该类提供线程局部变量。 这些变量不同于它们的正常对应物是每个访问一个（通过它或方法）的线程都有自己独立初始化的变量副本。 实例通常是希望将状态与线程相关联的类中的私有静态字段（例如，用户ID或事务ID）。 每个线程都拥有对其本地线程副本的隐式引用只要线程处于活动状态，就可以变量实例可访问; 一个线程消失后，它的所有副本程局部实例受垃圾回收（除非其他存在对这些副本的引用）。 那么到底什么意思呢？ThreadLocal提供了线程的局部变量，每个线程访问到的ThreadLocal并且往其中set()的变量是属于当前线程的，其他线程访问不到，实现了线程的数据隔离。 内部实现想要深入了解ThreadLocal，还是先看一下代码吧。123456789101112//JDK1.8中ThreadLocal的 set源码public void set(T value) &#123; //得到当前线程对象 Thread t = Thread.currentThread(); //获取当前线程对象的ThreadLocalMap ThreadLocalMap map = getMap(t); //如果map存在，则t作为key，要存的对象作为value，存到map中 if (map != null) map.set(this, value); else createMap(t, value); &#125; 看了这段代码 又有了疑问，什么是ThreadLocalMap？点进去看看1234567891011121314151617181920static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as &quot;stale entries&quot; in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; &#125; 原来ThreadLocalMap是ThreadLocal的一个内部类，数据是用Entry存储的。看看getMap方法123456ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; 什么是threadLocals？ threadLocals在Thread类中为线程维护的一个threadlocalMap ThreadLocal.ThreadLocalMap threadLocals = null; 这就清楚多了，从上面来看，一个Thread维护一个ThreadLocalMap，ThreadLocalMap的set方法的key是ThreadLocal本身，value是要存储的对象。再来看看get方法，有了以上的基础，那么看get方法我相信已经没有难度了1234567891011121314public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; // 还是根据当前线程对象从ThreadLocalMap的内部类Entry中取值 总结 一个Thread维护一个ThreadLocalMap set方法是通过ThreadLocalMap的内部类Entry来存储 ThreadLocalMap的set方法的key是ThreadLocal本身，value是要存储的对象 ThreadLocal是通过ThreadLocalMap来存储值，本身并不存储值，只是作为一个key 综上所述，ThreadLocal才能实现线程间的数据隔离]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引原理]]></title>
    <url>%2F2019%2F05%2F02%2FMySQL%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[索引目的索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？ 索引原理除了词典，生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(&gt;、&lt;、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。 索引的数据结构前面讲了生活中索引的例子，索引的基本原理，数据库的复杂性，又讲了操作系统的相关知识，目的就是让大家了解，任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，我们现在总结一下，我们需要这种数据结构能够做些什么，其实很简单，那就是：每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，b+树应运而生。 详解b+树如上图，是一颗b+树，关于b+树的定义可以参见B+树，这里只说一些重点，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。 b+树查找过程如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。 b+树性质 通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。 当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。 建索引的几大原则 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。 本文转载自：《美团技术团队：MySQL索引原理及慢查询优化》]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.18腾讯暑期实习招聘提前批一面(挂)]]></title>
    <url>%2F2019%2F04%2F16%2F2019-3-18%E8%85%BE%E8%AE%AF%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[3.18晚上9点 人生第一次面试 岗位：后台开发 我是做Java，但是估计面试官不是做Java的所以一点Java的东西也没问 了解redis高可用吗 异步队列怎么做的? redis和数据库的关系,是先写redis还是数据库 redis崩溃了如何减轻数据库的压力 用过什么redis命令 操作系统相关 select epoll 进程线程区别 进程通信方式 操作系统有哪些锁 TCP三次握手 粘包问题 如何访问到链表的中间节点暂时记得的只有这么多了 关于操作系统和场景题答的不好给自己敲了警钟，知道自己还差的远。在学习的时候一定要结合自己的思考，往深处挖，不能只是停留在表面，要理解原理。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java排序算法之插入排序]]></title>
    <url>%2F2019%2F04%2F16%2FJava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[什么是插入排序插入排序的基本思想就是把一个数插入到已经有序的数列中，形式就像平时打牌一样，要把一张牌插到已经有的牌中。这里只是要把牌看成数组。初始时要把数组的第一个元素看成有序列表，从第二个数开始，依次将当前数插入到前面的有序列表中。12345678910111213141516public static void main(String[] args)&#123; int[] arr=&#123;5,4,3,2,1&#125;; for(int i=1;i&lt;arr.length;i++)&#123; //第一次把第一个元素也就是数组的0位置上的数看成有序，所以从1位置也就是数组的第二个数开始 int temp=arr[i]; //当前数 int left=i-1; //把当前数的前面的所有数都看成有序列表 while(left&gt;=0&amp;&amp;temp&lt;arr[left])&#123; //依次和前面的数比较，如果当前数比前面的数小 就把前面的数后移一位，继续向前比，直到不比前面的数小为止 arr[left+1]=arr[left]; left--; &#125; arr[left+1]=temp; //把当前数插入，因为之前的元素都向后移了，总会有一个空的位置，这个位置就是这个数应该插入在有序列表中的位置 &#125; for(int a:arr)&#123; System.out.println(a);//由于此处采用的是从小到大排，所以结果应该为1,2,3,4,5 &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中接口和抽象类的区别]]></title>
    <url>%2F2019%2F04%2F15%2FJava%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类使用了关键词abstract声明的类叫作“抽象类”。如果一个类里包含了一个或多个抽象方法，类就必须指定成abstract（抽象）。“抽象方法”,属于一种不完整的方法，只含有一个声明，没有方法主体也就是没有{}，抽象类不能被实例化（也就是不能用抽象类new）。 接口接口是一系列方法的声明，是一些方法特征的集合，接口里面只有方法的声明而没有方法的实现，也就是没有方法主体，没有{}，里面的方法都是由public abstract修饰的。 区别 抽象类可以有具体的方法实现，而接口是完全抽象的，不能有方法实现。 子类使用extends继承抽象类，如果子类不是抽象类的话，要实现抽象类的全部抽象方法。子类使用implements实现接口，并且要实现接口声明的全部方法。 修饰符：抽象类可以用public protected和default这些修饰符，接口方法默认修饰符是public，不可以用其他修饰符。 抽象类可以有main方法也可以运行，接口不能有main，也不能运行。 抽象方法可以继承一个类和实现多个接口，接口只可以继承一个或多个其它接口。 抽象类比接口速度要快，因为接口需要时间去寻找在类中实现的方法。 往抽象类中添加新的方法可以直接提供实现，所以可以不用改变继承抽象类的子类，而向接口添加新的方法，必须改变接口的实现类。 抽象类可以有构造方法，只是不能创建抽象类的实例化对象，接口没有构造方法，不能被实例化。 什么时候使用抽象类？什么时候使用接口？ 如果拥有一些方法并且想让它们中的一些有默认实现，用抽象类。 由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。这时候可以使用接口解决问题。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
